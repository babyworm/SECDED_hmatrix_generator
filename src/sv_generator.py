"""
SystemVerilog Code Generator for SECDED Encoder/Decoder

This module generates production-quality SystemVerilog code following
IEEE 1800-2017 standards and industry best practices.

Code Style:
- snake_case for signals and modules
- UPPERCASE for parameters
- Active-low async reset (rst_n)
- always_ff for sequential logic with non-blocking assignments
- always_comb for combinational logic with blocking assignments
- No latches, all outputs assigned in all branches
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import List, Optional
from datetime import datetime

from src.gen_hmatrix import generate_h_matrix_secdec, Scheme


@dataclass
class SVGeneratorConfig:
    """Configuration for SystemVerilog code generation."""
    module_prefix: str = "secded"
    data_signal: str = "data_in"
    parity_signal: str = "parity_out"
    codeword_signal: str = "codeword"
    syndrome_signal: str = "syndrome"
    corrected_signal: str = "corrected_data"
    error_signal: str = "error_type"
    include_header: bool = True
    include_assertions: bool = True
    author: str = "SECDED Generator"


def _get_header(module_name: str, description: str, config: SVGeneratorConfig) -> str:
    """Generate file header comment."""
    date = datetime.now().strftime("%Y-%m-%d")
    return f"""//==============================================================================
// Module: {module_name}
// Description: {description}
// Author: {config.author}
// Date: {date}
//
// Generated by SECDED H-Matrix Generator
// IEEE 1800-2017 SystemVerilog
//==============================================================================
"""


def generate_encoder_sv(
    k: int,
    scheme: Scheme = "hsiao",
    config: Optional[SVGeneratorConfig] = None
) -> str:
    """
    Generate SystemVerilog encoder module.

    The encoder computes parity bits from data bits using the H-matrix.

    Args:
        k: Number of data bits
        scheme: "hamming" or "hsiao"
        config: Optional configuration

    Returns:
        Complete SystemVerilog module code
    """
    if config is None:
        config = SVGeneratorConfig()

    H, r = generate_h_matrix_secdec(k, scheme)
    n = k + r + 1  # total codeword length

    module_name = f"{config.module_prefix}_encoder_{k}"

    lines = []

    # Header
    if config.include_header:
        lines.append(_get_header(
            module_name,
            f"SECDED Encoder ({scheme.upper()}) - {k}-bit data, {r} parity bits",
            config
        ))

    lines.append(f"module {module_name} #(")
    lines.append(f"    parameter int DATA_WIDTH = {k},")
    lines.append(f"    parameter int PARITY_BITS = {r},")
    lines.append(f"    parameter int CODEWORD_WIDTH = {n}")
    lines.append(") (")
    lines.append("    // Clock and reset")
    lines.append("    input  logic                      clk,")
    lines.append("    input  logic                      rst_n,")
    lines.append("")
    lines.append("    // Input interface")
    lines.append("    input  logic                      input_valid,")
    lines.append("    output logic                      input_ready,")
    lines.append(f"    input  logic [DATA_WIDTH-1:0]    {config.data_signal},")
    lines.append("")
    lines.append("    // Output interface")
    lines.append("    output logic                      output_valid,")
    lines.append("    input  logic                      output_ready,")
    lines.append(f"    output logic [CODEWORD_WIDTH-1:0] {config.codeword_signal}")
    lines.append(");")
    lines.append("")

    # Internal signals
    lines.append("    // Internal signals")
    lines.append(f"    logic [PARITY_BITS-1:0] parity;")
    lines.append("    logic                   overall_parity;")
    lines.append("")

    # Parity bit computation (combinational)
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Parity Bit Computation (Combinational)")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    always_comb begin")

    for i in range(r):
        # Find data bits that contribute to this parity bit
        taps = []
        for j in range(k):
            if H[i][r + j] == 1:
                taps.append(f"{config.data_signal}[{j}]")

        if not taps:
            lines.append(f"        parity[{i}] = 1'b0;")
        else:
            # Build XOR expression
            xor_expr = " ^ ".join(taps)
            lines.append(f"        parity[{i}] = {xor_expr};")

    lines.append("    end")
    lines.append("")

    # Overall parity computation
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Overall Parity (XOR of all parity and data bits)")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    always_comb begin")
    lines.append(f"        overall_parity = ^parity ^ ^{config.data_signal};")
    lines.append("    end")
    lines.append("")

    # Output codeword assembly
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Codeword Assembly: [parity | data | overall_parity]")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    always_comb begin")
    lines.append(f"        {config.codeword_signal} = {{overall_parity, {config.data_signal}, parity}};")
    lines.append("    end")
    lines.append("")

    # Pipeline registers (optional - for timing)
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Pipeline Control (valid/ready handshake)")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    logic output_valid_reg;")
    lines.append("")
    lines.append("    always_ff @(posedge clk or negedge rst_n) begin")
    lines.append("        if (!rst_n) begin")
    lines.append("            output_valid_reg <= 1'b0;")
    lines.append("        end else begin")
    lines.append("            output_valid_reg <= input_valid && input_ready;")
    lines.append("        end")
    lines.append("    end")
    lines.append("")
    lines.append("    assign output_valid = output_valid_reg;")
    lines.append("    assign input_ready = !output_valid_reg || output_ready;")
    lines.append("")

    # Assertions
    if config.include_assertions:
        lines.append("    //--------------------------------------------------------------------------")
        lines.append("    // Assertions (Simulation Only)")
        lines.append("    //--------------------------------------------------------------------------")
        lines.append("    // synthesis translate_off")
        lines.append("    // synopsys translate_off")
        lines.append("")
        lines.append("    // Check codeword width")
        lines.append(f"    initial begin")
        lines.append(f"        assert (CODEWORD_WIDTH == DATA_WIDTH + PARITY_BITS + 1)")
        lines.append(f'            else $error("Codeword width mismatch");')
        lines.append("    end")
        lines.append("")
        lines.append("    // synopsys translate_on")
        lines.append("    // synthesis translate_on")
        lines.append("")

    lines.append("endmodule")

    return "\n".join(lines)


def generate_decoder_sv(
    k: int,
    scheme: Scheme = "hsiao",
    config: Optional[SVGeneratorConfig] = None
) -> str:
    """
    Generate SystemVerilog decoder module.

    The decoder performs:
    1. Syndrome computation
    2. Error detection (single/double bit)
    3. Error correction (single bit only)

    Args:
        k: Number of data bits
        scheme: "hamming" or "hsiao"
        config: Optional configuration

    Returns:
        Complete SystemVerilog module code
    """
    if config is None:
        config = SVGeneratorConfig()

    H, r = generate_h_matrix_secdec(k, scheme)
    n = k + r + 1  # total codeword length

    module_name = f"{config.module_prefix}_decoder_{k}"

    lines = []

    # Header
    if config.include_header:
        lines.append(_get_header(
            module_name,
            f"SECDED Decoder ({scheme.upper()}) - {k}-bit data, {r} parity bits",
            config
        ))

    lines.append(f"module {module_name} #(")
    lines.append(f"    parameter int DATA_WIDTH = {k},")
    lines.append(f"    parameter int PARITY_BITS = {r},")
    lines.append(f"    parameter int CODEWORD_WIDTH = {n}")
    lines.append(") (")
    lines.append("    // Clock and reset")
    lines.append("    input  logic                       clk,")
    lines.append("    input  logic                       rst_n,")
    lines.append("")
    lines.append("    // Input interface")
    lines.append("    input  logic                       input_valid,")
    lines.append("    output logic                       input_ready,")
    lines.append(f"    input  logic [CODEWORD_WIDTH-1:0] {config.codeword_signal},")
    lines.append("")
    lines.append("    // Output interface")
    lines.append("    output logic                       output_valid,")
    lines.append("    input  logic                       output_ready,")
    lines.append(f"    output logic [DATA_WIDTH-1:0]     {config.corrected_signal},")
    lines.append("")
    lines.append("    // Error status")
    lines.append(f"    output logic [PARITY_BITS-1:0]    {config.syndrome_signal},")
    lines.append("    output logic                       overall_parity,")
    lines.append("    output logic [1:0]                 error_type,  // 00=none, 01=corrected, 10=detected, 11=unknown")
    lines.append("    output logic                       error_corrected")
    lines.append(");")
    lines.append("")

    # Error type encoding
    lines.append("    // Error type encoding")
    lines.append("    localparam logic [1:0] ERR_NONE      = 2'b00;")
    lines.append("    localparam logic [1:0] ERR_CORRECTED = 2'b01;")
    lines.append("    localparam logic [1:0] ERR_DETECTED  = 2'b10;")
    lines.append("    localparam logic [1:0] ERR_UNKNOWN   = 2'b11;")
    lines.append("")

    # Internal signals
    lines.append("    // Internal signals")
    lines.append(f"    logic [PARITY_BITS-1:0]    parity_bits;")
    lines.append(f"    logic [DATA_WIDTH-1:0]     data_bits;")
    lines.append("    logic                       overall_parity_bit;")
    lines.append(f"    logic [PARITY_BITS-1:0]    syndrome_comb;")
    lines.append("    logic                       overall_parity_comb;")
    lines.append(f"    logic [CODEWORD_WIDTH-1:0] corrected_codeword;")
    lines.append(f"    logic [$clog2(CODEWORD_WIDTH)-1:0] error_position;")
    lines.append("    logic                       position_valid;")
    lines.append("")

    # Codeword decomposition
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Codeword Decomposition")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    always_comb begin")
    lines.append(f"        parity_bits        = {config.codeword_signal}[PARITY_BITS-1:0];")
    lines.append(f"        data_bits          = {config.codeword_signal}[PARITY_BITS+DATA_WIDTH-1:PARITY_BITS];")
    lines.append(f"        overall_parity_bit = {config.codeword_signal}[CODEWORD_WIDTH-1];")
    lines.append("    end")
    lines.append("")

    # Syndrome computation
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Syndrome Computation")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    always_comb begin")

    for i in range(r):
        # Build syndrome equation: XOR of all codeword bits where H[i][j] == 1
        taps = []
        for j in range(n - 1):  # exclude overall parity column
            if H[i][j] == 1:
                if j < r:
                    taps.append(f"parity_bits[{j}]")
                else:
                    taps.append(f"data_bits[{j - r}]")

        if not taps:
            lines.append(f"        syndrome_comb[{i}] = 1'b0;")
        else:
            xor_expr = " ^ ".join(taps)
            lines.append(f"        syndrome_comb[{i}] = {xor_expr};")

    lines.append("    end")
    lines.append("")

    # Overall parity computation
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Overall Parity Check")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    always_comb begin")
    lines.append(f"        overall_parity_comb = ^{config.codeword_signal};")
    lines.append("    end")
    lines.append("")

    # Build column value lookup table
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Error Position Lookup (Column Matching)")
    lines.append("    //--------------------------------------------------------------------------")

    # Pre-compute column values for the H-matrix
    col_values = []
    for col in range(n - 1):  # exclude overall parity column
        val = 0
        for row in range(r):
            val |= (H[row][col] << row)
        col_values.append(val)

    lines.append("    always_comb begin")
    lines.append(f"        error_position = '0;")
    lines.append("        position_valid = 1'b0;")
    lines.append("")
    lines.append("        case (syndrome_comb)")

    # Generate case statements for each possible syndrome
    for col, val in enumerate(col_values):
        if val != 0:
            lines.append(f"            {r}'d{val}: begin")
            lines.append(f"                error_position = {col};")
            lines.append("                position_valid = 1'b1;")
            lines.append("            end")

    lines.append("            default: begin")
    lines.append(f"                error_position = '0;")
    lines.append("                position_valid = 1'b0;")
    lines.append("            end")
    lines.append("        endcase")
    lines.append("    end")
    lines.append("")

    # Error correction logic
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Error Correction Logic")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    always_comb begin")
    lines.append("        // Default: no correction")
    lines.append(f"        corrected_codeword = {config.codeword_signal};")
    lines.append("        error_type = ERR_NONE;")
    lines.append("        error_corrected = 1'b0;")
    lines.append("")
    lines.append("        if (syndrome_comb == '0 && overall_parity_comb == 1'b0) begin")
    lines.append("            // No error")
    lines.append("            error_type = ERR_NONE;")
    lines.append("        end")
    lines.append("        else if (syndrome_comb == '0 && overall_parity_comb == 1'b1) begin")
    lines.append("            // Overall parity bit error only")
    lines.append("            error_type = ERR_CORRECTED;")
    lines.append("            error_corrected = 1'b1;")
    lines.append("            corrected_codeword[CODEWORD_WIDTH-1] = ~overall_parity_bit;")
    lines.append("        end")
    lines.append("        else if (syndrome_comb != '0 && overall_parity_comb == 1'b1) begin")
    lines.append("            // Single bit error - correctable")
    lines.append("            if (position_valid) begin")
    lines.append("                error_type = ERR_CORRECTED;")
    lines.append("                error_corrected = 1'b1;")
    lines.append("                corrected_codeword[error_position] = ~corrected_codeword[error_position];")
    lines.append("            end else begin")
    lines.append("                error_type = ERR_UNKNOWN;")
    lines.append("            end")
    lines.append("        end")
    lines.append("        else begin  // syndrome != 0 && overall_parity == 0")
    lines.append("            // Double bit error - detected but not correctable")
    lines.append("            error_type = ERR_DETECTED;")
    lines.append("        end")
    lines.append("    end")
    lines.append("")

    # Output extraction
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Output Extraction")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    always_comb begin")
    lines.append(f"        {config.corrected_signal} = corrected_codeword[PARITY_BITS+DATA_WIDTH-1:PARITY_BITS];")
    lines.append(f"        {config.syndrome_signal} = syndrome_comb;")
    lines.append("        overall_parity = overall_parity_comb;")
    lines.append("    end")
    lines.append("")

    # Pipeline control
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Pipeline Control")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    logic output_valid_reg;")
    lines.append("")
    lines.append("    always_ff @(posedge clk or negedge rst_n) begin")
    lines.append("        if (!rst_n) begin")
    lines.append("            output_valid_reg <= 1'b0;")
    lines.append("        end else begin")
    lines.append("            output_valid_reg <= input_valid && input_ready;")
    lines.append("        end")
    lines.append("    end")
    lines.append("")
    lines.append("    assign output_valid = output_valid_reg;")
    lines.append("    assign input_ready = !output_valid_reg || output_ready;")
    lines.append("")

    lines.append("endmodule")

    return "\n".join(lines)


def generate_top_module_sv(
    k: int,
    scheme: Scheme = "hsiao",
    config: Optional[SVGeneratorConfig] = None
) -> str:
    """
    Generate top-level SECDED module that includes both encoder and decoder.

    Args:
        k: Number of data bits
        scheme: "hamming" or "hsiao"
        config: Optional configuration

    Returns:
        Complete SystemVerilog module code
    """
    if config is None:
        config = SVGeneratorConfig()

    H, r = generate_h_matrix_secdec(k, scheme)
    n = k + r + 1

    module_name = f"{config.module_prefix}_top_{k}"
    encoder_name = f"{config.module_prefix}_encoder_{k}"
    decoder_name = f"{config.module_prefix}_decoder_{k}"

    lines = []

    if config.include_header:
        lines.append(_get_header(
            module_name,
            f"SECDED Top Module ({scheme.upper()}) - {k}-bit data",
            config
        ))

    lines.append(f"module {module_name} #(")
    lines.append(f"    parameter int DATA_WIDTH = {k},")
    lines.append(f"    parameter int PARITY_BITS = {r},")
    lines.append(f"    parameter int CODEWORD_WIDTH = {n}")
    lines.append(") (")
    lines.append("    input  logic                       clk,")
    lines.append("    input  logic                       rst_n,")
    lines.append("")
    lines.append("    // Encoder interface")
    lines.append("    input  logic                       enc_input_valid,")
    lines.append("    output logic                       enc_input_ready,")
    lines.append("    input  logic [DATA_WIDTH-1:0]      enc_data_in,")
    lines.append("    output logic                       enc_output_valid,")
    lines.append("    input  logic                       enc_output_ready,")
    lines.append("    output logic [CODEWORD_WIDTH-1:0]  enc_codeword_out,")
    lines.append("")
    lines.append("    // Decoder interface")
    lines.append("    input  logic                       dec_input_valid,")
    lines.append("    output logic                       dec_input_ready,")
    lines.append("    input  logic [CODEWORD_WIDTH-1:0]  dec_codeword_in,")
    lines.append("    output logic                       dec_output_valid,")
    lines.append("    input  logic                       dec_output_ready,")
    lines.append("    output logic [DATA_WIDTH-1:0]      dec_data_out,")
    lines.append("    output logic [PARITY_BITS-1:0]     dec_syndrome,")
    lines.append("    output logic                       dec_overall_parity,")
    lines.append("    output logic [1:0]                 dec_error_type,")
    lines.append("    output logic                       dec_error_corrected")
    lines.append(");")
    lines.append("")

    # Encoder instance
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Encoder Instance")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append(f"    {encoder_name} #(")
    lines.append("        .DATA_WIDTH(DATA_WIDTH),")
    lines.append("        .PARITY_BITS(PARITY_BITS),")
    lines.append("        .CODEWORD_WIDTH(CODEWORD_WIDTH)")
    lines.append("    ) u_encoder (")
    lines.append("        .clk(clk),")
    lines.append("        .rst_n(rst_n),")
    lines.append("        .input_valid(enc_input_valid),")
    lines.append("        .input_ready(enc_input_ready),")
    lines.append("        .data_in(enc_data_in),")
    lines.append("        .output_valid(enc_output_valid),")
    lines.append("        .output_ready(enc_output_ready),")
    lines.append("        .codeword(enc_codeword_out)")
    lines.append("    );")
    lines.append("")

    # Decoder instance
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Decoder Instance")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append(f"    {decoder_name} #(")
    lines.append("        .DATA_WIDTH(DATA_WIDTH),")
    lines.append("        .PARITY_BITS(PARITY_BITS),")
    lines.append("        .CODEWORD_WIDTH(CODEWORD_WIDTH)")
    lines.append("    ) u_decoder (")
    lines.append("        .clk(clk),")
    lines.append("        .rst_n(rst_n),")
    lines.append("        .input_valid(dec_input_valid),")
    lines.append("        .input_ready(dec_input_ready),")
    lines.append("        .codeword(dec_codeword_in),")
    lines.append("        .output_valid(dec_output_valid),")
    lines.append("        .output_ready(dec_output_ready),")
    lines.append("        .corrected_data(dec_data_out),")
    lines.append("        .syndrome(dec_syndrome),")
    lines.append("        .overall_parity(dec_overall_parity),")
    lines.append("        .error_type(dec_error_type),")
    lines.append("        .error_corrected(dec_error_corrected)")
    lines.append("    );")
    lines.append("")
    lines.append("endmodule")

    return "\n".join(lines)


def generate_testbench_sv(
    k: int,
    scheme: Scheme = "hsiao",
    config: Optional[SVGeneratorConfig] = None
) -> str:
    """
    Generate SystemVerilog testbench for SECDED encoder/decoder.

    Args:
        k: Number of data bits
        scheme: "hamming" or "hsiao"
        config: Optional configuration

    Returns:
        Complete SystemVerilog testbench code
    """
    if config is None:
        config = SVGeneratorConfig()

    H, r = generate_h_matrix_secdec(k, scheme)
    n = k + r + 1

    module_name = f"tb_{config.module_prefix}_{k}"
    encoder_name = f"{config.module_prefix}_encoder_{k}"
    decoder_name = f"{config.module_prefix}_decoder_{k}"

    lines = []

    if config.include_header:
        lines.append(_get_header(
            module_name,
            f"SECDED Testbench ({scheme.upper()}) - {k}-bit data",
            config
        ))

    lines.append("`timescale 1ns/1ps")
    lines.append("")
    lines.append(f"module {module_name};")
    lines.append("")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Parameters")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append(f"    localparam int DATA_WIDTH = {k};")
    lines.append(f"    localparam int PARITY_BITS = {r};")
    lines.append(f"    localparam int CODEWORD_WIDTH = {n};")
    lines.append("    localparam time CLK_PERIOD = 10ns;")
    lines.append("")

    # Signals
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Signals")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    logic clk;")
    lines.append("    logic rst_n;")
    lines.append("")
    lines.append("    // Encoder signals")
    lines.append("    logic                       enc_input_valid;")
    lines.append("    logic                       enc_input_ready;")
    lines.append("    logic [DATA_WIDTH-1:0]      enc_data_in;")
    lines.append("    logic                       enc_output_valid;")
    lines.append("    logic                       enc_output_ready;")
    lines.append("    logic [CODEWORD_WIDTH-1:0]  enc_codeword;")
    lines.append("")
    lines.append("    // Decoder signals")
    lines.append("    logic                       dec_input_valid;")
    lines.append("    logic                       dec_input_ready;")
    lines.append("    logic [CODEWORD_WIDTH-1:0]  dec_codeword;")
    lines.append("    logic                       dec_output_valid;")
    lines.append("    logic                       dec_output_ready;")
    lines.append("    logic [DATA_WIDTH-1:0]      dec_corrected_data;")
    lines.append("    logic [PARITY_BITS-1:0]     dec_syndrome;")
    lines.append("    logic                       dec_overall_parity;")
    lines.append("    logic [1:0]                 dec_error_type;")
    lines.append("    logic                       dec_error_corrected;")
    lines.append("")
    lines.append("    // Test variables")
    lines.append("    int test_count;")
    lines.append("    int pass_count;")
    lines.append("    int fail_count;")
    lines.append("")

    # Clock generation
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Clock Generation")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    initial begin")
    lines.append("        clk = 1'b0;")
    lines.append("        forever #(CLK_PERIOD/2) clk = ~clk;")
    lines.append("    end")
    lines.append("")

    # DUT instances
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // DUT Instances")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append(f"    {encoder_name} #(")
    lines.append("        .DATA_WIDTH(DATA_WIDTH),")
    lines.append("        .PARITY_BITS(PARITY_BITS),")
    lines.append("        .CODEWORD_WIDTH(CODEWORD_WIDTH)")
    lines.append("    ) u_encoder (")
    lines.append("        .clk(clk),")
    lines.append("        .rst_n(rst_n),")
    lines.append("        .input_valid(enc_input_valid),")
    lines.append("        .input_ready(enc_input_ready),")
    lines.append("        .data_in(enc_data_in),")
    lines.append("        .output_valid(enc_output_valid),")
    lines.append("        .output_ready(enc_output_ready),")
    lines.append("        .codeword(enc_codeword)")
    lines.append("    );")
    lines.append("")
    lines.append(f"    {decoder_name} #(")
    lines.append("        .DATA_WIDTH(DATA_WIDTH),")
    lines.append("        .PARITY_BITS(PARITY_BITS),")
    lines.append("        .CODEWORD_WIDTH(CODEWORD_WIDTH)")
    lines.append("    ) u_decoder (")
    lines.append("        .clk(clk),")
    lines.append("        .rst_n(rst_n),")
    lines.append("        .input_valid(dec_input_valid),")
    lines.append("        .input_ready(dec_input_ready),")
    lines.append("        .codeword(dec_codeword),")
    lines.append("        .output_valid(dec_output_valid),")
    lines.append("        .output_ready(dec_output_ready),")
    lines.append("        .corrected_data(dec_corrected_data),")
    lines.append("        .syndrome(dec_syndrome),")
    lines.append("        .overall_parity(dec_overall_parity),")
    lines.append("        .error_type(dec_error_type),")
    lines.append("        .error_corrected(dec_error_corrected)")
    lines.append("    );")
    lines.append("")

    # Tasks
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Tasks")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    task automatic reset();")
    lines.append("        rst_n = 1'b0;")
    lines.append("        enc_input_valid = 1'b0;")
    lines.append("        enc_output_ready = 1'b1;")
    lines.append("        dec_input_valid = 1'b0;")
    lines.append("        dec_output_ready = 1'b1;")
    lines.append("        enc_data_in = '0;")
    lines.append("        dec_codeword = '0;")
    lines.append("        repeat(5) @(posedge clk);")
    lines.append("        rst_n = 1'b1;")
    lines.append("        repeat(2) @(posedge clk);")
    lines.append("    endtask")
    lines.append("")
    lines.append("    task automatic encode_data(input logic [DATA_WIDTH-1:0] data);")
    lines.append("        enc_data_in = data;")
    lines.append("        enc_input_valid = 1'b1;")
    lines.append("        @(posedge clk);")
    lines.append("        while (!enc_input_ready) @(posedge clk);")
    lines.append("        enc_input_valid = 1'b0;")
    lines.append("        @(posedge clk);")
    lines.append("        while (!enc_output_valid) @(posedge clk);")
    lines.append("    endtask")
    lines.append("")
    lines.append("    task automatic decode_codeword(input logic [CODEWORD_WIDTH-1:0] cw);")
    lines.append("        dec_codeword = cw;")
    lines.append("        dec_input_valid = 1'b1;")
    lines.append("        @(posedge clk);")
    lines.append("        while (!dec_input_ready) @(posedge clk);")
    lines.append("        dec_input_valid = 1'b0;")
    lines.append("        @(posedge clk);")
    lines.append("        while (!dec_output_valid) @(posedge clk);")
    lines.append("    endtask")
    lines.append("")
    lines.append("    task automatic check_result(")
    lines.append("        input string test_name,")
    lines.append("        input logic [DATA_WIDTH-1:0] expected_data,")
    lines.append("        input logic [1:0] expected_error_type")
    lines.append("    );")
    lines.append("        test_count++;")
    lines.append("        if (dec_corrected_data === expected_data && dec_error_type === expected_error_type) begin")
    lines.append("            pass_count++;")
    lines.append('            $display("[PASS] %s", test_name);')
    lines.append("        end else begin")
    lines.append("            fail_count++;")
    lines.append('            $display("[FAIL] %s - Expected data: %h, Got: %h, Expected error: %b, Got: %b",')
    lines.append("                     test_name, expected_data, dec_corrected_data,")
    lines.append("                     expected_error_type, dec_error_type);")
    lines.append("        end")
    lines.append("    endtask")
    lines.append("")

    # Main test
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Main Test Sequence")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    initial begin")
    lines.append('        $display("========================================");')
    lines.append(f'        $display("SECDED Testbench ({scheme.upper()}, {k}-bit)");')
    lines.append('        $display("========================================");')
    lines.append("")
    lines.append("        test_count = 0;")
    lines.append("        pass_count = 0;")
    lines.append("        fail_count = 0;")
    lines.append("")
    lines.append("        reset();")
    lines.append("")
    lines.append("        //----------------------------------------------------------------------")
    lines.append("        // Test 1: No Error")
    lines.append("        //----------------------------------------------------------------------")
    lines.append('        $display("\\n--- Test 1: No Error ---");')
    lines.append("        begin")
    lines.append("            logic [DATA_WIDTH-1:0] test_data;")
    lines.append("            test_data = {DATA_WIDTH{1'b1}} >> 1;  // All ones except MSB")
    lines.append("            encode_data(test_data);")
    lines.append("            decode_codeword(enc_codeword);")
    lines.append('            check_result("No error decode", test_data, 2\'b00);')
    lines.append("        end")
    lines.append("")
    lines.append("        //----------------------------------------------------------------------")
    lines.append("        // Test 2: Single Bit Error in Data")
    lines.append("        //----------------------------------------------------------------------")
    lines.append('        $display("\\n--- Test 2: Single Bit Error ---");')
    lines.append("        begin")
    lines.append("            logic [DATA_WIDTH-1:0] test_data;")
    lines.append("            logic [CODEWORD_WIDTH-1:0] corrupted;")
    lines.append("            test_data = 'hA5A5A5A5;")
    lines.append("            encode_data(test_data);")
    lines.append("            corrupted = enc_codeword ^ (1 << PARITY_BITS);  // Flip first data bit")
    lines.append("            decode_codeword(corrupted);")
    lines.append('            check_result("Single bit error correction", test_data, 2\'b01);')
    lines.append("        end")
    lines.append("")
    lines.append("        //----------------------------------------------------------------------")
    lines.append("        // Test 3: Double Bit Error")
    lines.append("        //----------------------------------------------------------------------")
    lines.append('        $display("\\n--- Test 3: Double Bit Error ---");')
    lines.append("        begin")
    lines.append("            logic [DATA_WIDTH-1:0] test_data;")
    lines.append("            logic [CODEWORD_WIDTH-1:0] corrupted;")
    lines.append("            test_data = 'h12345678;")
    lines.append("            encode_data(test_data);")
    lines.append("            corrupted = enc_codeword ^ (3 << PARITY_BITS);  // Flip two adjacent bits")
    lines.append("            decode_codeword(corrupted);")
    lines.append("            test_count++;")
    lines.append("            if (dec_error_type === 2'b10) begin")
    lines.append("                pass_count++;")
    lines.append('                $display("[PASS] Double bit error detection");')
    lines.append("            end else begin")
    lines.append("                fail_count++;")
    lines.append('                $display("[FAIL] Double bit error detection - Expected error type: 10, Got: %b", dec_error_type);')
    lines.append("            end")
    lines.append("        end")
    lines.append("")
    lines.append("        //----------------------------------------------------------------------")
    lines.append("        // Test 4: All Zeros")
    lines.append("        //----------------------------------------------------------------------")
    lines.append('        $display("\\n--- Test 4: All Zeros ---");')
    lines.append("        begin")
    lines.append("            encode_data('0);")
    lines.append("            decode_codeword(enc_codeword);")
    lines.append('            check_result("All zeros", \'0, 2\'b00);')
    lines.append("        end")
    lines.append("")
    lines.append("        //----------------------------------------------------------------------")
    lines.append("        // Test 5: All Ones")
    lines.append("        //----------------------------------------------------------------------")
    lines.append('        $display("\\n--- Test 5: All Ones ---");')
    lines.append("        begin")
    lines.append("            logic [DATA_WIDTH-1:0] all_ones;")
    lines.append("            all_ones = {DATA_WIDTH{1'b1}};")
    lines.append("            encode_data(all_ones);")
    lines.append("            decode_codeword(enc_codeword);")
    lines.append('            check_result("All ones", all_ones, 2\'b00);')
    lines.append("        end")
    lines.append("")
    lines.append("        //----------------------------------------------------------------------")
    lines.append("        // Test 6: Random Data")
    lines.append("        //----------------------------------------------------------------------")
    lines.append('        $display("\\n--- Test 6: Random Data ---");')
    lines.append("        for (int i = 0; i < 10; i++) begin")
    lines.append("            logic [DATA_WIDTH-1:0] rand_data;")
    lines.append("            rand_data = $urandom();")
    lines.append("            encode_data(rand_data);")
    lines.append("            decode_codeword(enc_codeword);")
    lines.append('            check_result($sformatf("Random data %0d", i), rand_data, 2\'b00);')
    lines.append("        end")
    lines.append("")
    lines.append("        //----------------------------------------------------------------------")
    lines.append("        // Summary")
    lines.append("        //----------------------------------------------------------------------")
    lines.append('        $display("\\n========================================");')
    lines.append('        $display("Test Summary");')
    lines.append('        $display("========================================");')
    lines.append('        $display("Total: %0d, Pass: %0d, Fail: %0d", test_count, pass_count, fail_count);')
    lines.append("        if (fail_count == 0)")
    lines.append('            $display("ALL TESTS PASSED!");')
    lines.append("        else")
    lines.append('            $display("SOME TESTS FAILED!");')
    lines.append('        $display("========================================");')
    lines.append("")
    lines.append("        $finish;")
    lines.append("    end")
    lines.append("")
    lines.append("endmodule")

    return "\n".join(lines)


def generate_package_sv(
    k: int,
    scheme: Scheme = "hsiao",
    config: Optional[SVGeneratorConfig] = None
) -> str:
    """
    Generate SystemVerilog package with type definitions.

    Args:
        k: Number of data bits
        scheme: "hamming" or "hsiao"
        config: Optional configuration

    Returns:
        Complete SystemVerilog package code
    """
    if config is None:
        config = SVGeneratorConfig()

    H, r = generate_h_matrix_secdec(k, scheme)
    n = k + r + 1

    package_name = f"{config.module_prefix}_pkg"

    lines = []

    if config.include_header:
        lines.append(_get_header(
            package_name,
            f"SECDED Package ({scheme.upper()}) - Type definitions and constants",
            config
        ))

    lines.append(f"package {package_name};")
    lines.append("")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Constants")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append(f"    localparam int DATA_WIDTH = {k};")
    lines.append(f"    localparam int PARITY_BITS = {r};")
    lines.append(f"    localparam int CODEWORD_WIDTH = {n};")
    lines.append("")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Error Type Enumeration")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    typedef enum logic [1:0] {")
    lines.append("        ERR_NONE      = 2'b00,  // No error detected")
    lines.append("        ERR_CORRECTED = 2'b01,  // Single bit error corrected")
    lines.append("        ERR_DETECTED  = 2'b10,  // Double bit error detected (uncorrectable)")
    lines.append("        ERR_UNKNOWN   = 2'b11   // Unknown error pattern")
    lines.append("    } error_type_e;")
    lines.append("")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Data Types")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    typedef logic [DATA_WIDTH-1:0]     data_t;")
    lines.append("    typedef logic [PARITY_BITS-1:0]    parity_t;")
    lines.append("    typedef logic [CODEWORD_WIDTH-1:0] codeword_t;")
    lines.append("    typedef logic [PARITY_BITS-1:0]    syndrome_t;")
    lines.append("")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    // Decoder Result Structure")
    lines.append("    //--------------------------------------------------------------------------")
    lines.append("    typedef struct packed {")
    lines.append("        data_t       corrected_data;")
    lines.append("        syndrome_t   syndrome;")
    lines.append("        logic        overall_parity;")
    lines.append("        error_type_e error_type;")
    lines.append("        logic        error_corrected;")
    lines.append("    } decode_result_t;")
    lines.append("")
    lines.append("endpackage")

    return "\n".join(lines)


def generate_all_sv_files(
    k: int,
    scheme: Scheme = "hsiao",
    output_dir: str = ".",
    config: Optional[SVGeneratorConfig] = None
) -> dict:
    """
    Generate all SystemVerilog files for a complete SECDED implementation.

    Args:
        k: Number of data bits
        scheme: "hamming" or "hsiao"
        output_dir: Output directory path
        config: Optional configuration

    Returns:
        Dictionary mapping filename to content
    """
    if config is None:
        config = SVGeneratorConfig()

    files = {}

    prefix = config.module_prefix

    # Package
    files[f"{prefix}_pkg.sv"] = generate_package_sv(k, scheme, config)

    # Encoder
    files[f"{prefix}_encoder_{k}.sv"] = generate_encoder_sv(k, scheme, config)

    # Decoder
    files[f"{prefix}_decoder_{k}.sv"] = generate_decoder_sv(k, scheme, config)

    # Top module
    files[f"{prefix}_top_{k}.sv"] = generate_top_module_sv(k, scheme, config)

    # Testbench
    files[f"tb_{prefix}_{k}.sv"] = generate_testbench_sv(k, scheme, config)

    return files


# Demo
if __name__ == "__main__":
    # Generate example for 64-bit data
    print("=== SECDED Encoder (64-bit, Hsiao) ===")
    print(generate_encoder_sv(64, "hsiao"))
