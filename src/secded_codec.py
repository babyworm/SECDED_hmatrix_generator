"""
SECDED (Single Error Correction, Double Error Detection) Codec

This module provides encoding and decoding functionality for SECDED codes
using H-matrices generated by gen_hmatrix.py.

The H-matrix structure (from gen_hmatrix.py):
- Dimensions: (r+1) x (k+r+1) binary matrix
- Column order: [p0..p{r-1} | d0..d{k-1} | p_overall]
- Row order: [s0..s{r-1} | overall_row]

where:
- k = number of data bits
- r = number of SEC parity bits
- n = k + r + 1 = total codeword length (including overall parity)
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import List, Tuple, Optional


@dataclass
class SECDEDResult:
    """Result of SECDED decoding operation.

    Attributes:
        corrected_data: Corrected data as integer (k bits)
        syndrome: Syndrome value as integer (r bits)
        overall_parity: Overall parity bit (0 or 1)
        error_type: Type of error detected/corrected:
            - "none": No error detected
            - "single_corrected": Single bit error corrected
            - "double_detected": Double bit error detected (uncorrectable)
            - "unknown": Unknown error pattern
        error_position: Position of error in codeword (0-indexed), None if no single error
        corrected: True if a correction was applied
    """
    corrected_data: int
    syndrome: int
    overall_parity: int
    error_type: str
    error_position: Optional[int]
    corrected: bool


def _int_to_bits(value: int, width: int) -> List[int]:
    """Convert integer to list of bits (LSB first)."""
    return [(value >> i) & 1 for i in range(width)]


def _bits_to_int(bits: List[int]) -> int:
    """Convert list of bits (LSB first) to integer."""
    result = 0
    for i, bit in enumerate(bits):
        if bit:
            result |= (1 << i)
    return result


def encode(data: int, H: List[List[int]], r: int, k: int) -> List[int]:
    """Encode data bits into SECDED codeword.

    Args:
        data: Data value as integer (k bits)
        H: H-matrix of shape (r+1) x (k+r+1) from generate_h_matrix_secdec
        r: Number of SEC parity bits
        k: Number of data bits

    Returns:
        Codeword as list of n = k+r+1 bits in order: [p0..p{r-1}, d0..d{k-1}, p_overall]

    The encoding process:
        1. Compute SEC parity bits: p[i] = XOR of d[j] where H[i][r+j] == 1
        2. Compute overall parity: p_overall = XOR of all (parity bits + data bits)
    """
    n = k + r + 1
    data_bits = _int_to_bits(data, k)

    # Initialize codeword: [p0..p{r-1}, d0..d{k-1}, p_overall]
    codeword = [0] * n

    # Place data bits in positions r through r+k-1
    for i in range(k):
        codeword[r + i] = data_bits[i]

    # Compute SEC parity bits p[i] for i in 0..r-1
    # p[i] = XOR of d[j] where H[i][r+j] == 1
    for i in range(r):
        parity = 0
        for j in range(k):
            if H[i][r + j] == 1:
                parity ^= data_bits[j]
        codeword[i] = parity

    # Compute overall parity bit (last position)
    # p_overall = XOR of all parity bits and data bits
    overall = 0
    for i in range(r + k):
        overall ^= codeword[i]
    codeword[n - 1] = overall

    return codeword


def compute_syndrome(codeword: List[int], H: List[List[int]], r: int) -> Tuple[int, int]:
    """Compute syndrome and overall parity for a codeword.

    Args:
        codeword: Received codeword of n = k+r+1 bits
        H: H-matrix of shape (r+1) x (k+r+1)
        r: Number of SEC parity bits

    Returns:
        Tuple of (syndrome_value, overall_parity):
            - syndrome_value: r-bit syndrome as integer (bits s0..s{r-1})
            - overall_parity: Overall parity check result (0 or 1)

    Computation:
        - syndrome[i] = XOR of codeword[j] where H[i][j] == 1, for i in 0..r-1
        - overall_parity = XOR of all n codeword bits
    """
    n = len(codeword)

    # Compute syndrome bits s[i] for i in 0..r-1
    syndrome = 0
    for i in range(r):
        s_bit = 0
        for j in range(n):
            if H[i][j] == 1:
                s_bit ^= codeword[j]
        # Build syndrome as integer: s0 is LSB, s{r-1} is MSB
        syndrome |= (s_bit << i)

    # Compute overall parity (XOR of entire codeword)
    overall = 0
    for bit in codeword:
        overall ^= bit

    return syndrome, overall


def decode(codeword: List[int], H: List[List[int]], r: int, k: int) -> SECDEDResult:
    """Decode SECDED codeword with error detection and correction.

    Args:
        codeword: Received codeword of n = k+r+1 bits
        H: H-matrix of shape (r+1) x (k+r+1)
        r: Number of SEC parity bits
        k: Number of data bits

    Returns:
        SECDEDResult containing corrected data and error information

    Error Detection Logic:
        - syndrome == 0, overall == 0: No error
        - syndrome != 0, overall == 1: Single bit error (correctable)
        - syndrome != 0, overall == 0: Double bit error (detectable, not correctable)
        - syndrome == 0, overall == 1: Overall parity bit error only
    """
    n = len(codeword)

    # Compute syndrome and overall parity
    syndrome, overall = compute_syndrome(codeword, H, r)

    # Make a copy of codeword for correction
    corrected_codeword = codeword.copy()
    error_position = None
    corrected = False

    # Determine error type and correct if possible
    if syndrome == 0 and overall == 0:
        # No error
        error_type = "none"

    elif syndrome == 0 and overall == 1:
        # Overall parity bit error only (position n-1)
        error_type = "single_corrected"
        error_position = n - 1
        corrected_codeword[error_position] ^= 1
        corrected = True

    elif syndrome != 0 and overall == 1:
        # Single bit error - find and correct
        error_type = "single_corrected"
        corrected = True

        # Find column in H that matches syndrome pattern
        for col in range(n):
            # Compute column value from H[0..r-1][col]
            col_value = 0
            for row in range(r):
                col_value |= (H[row][col] << row)

            if col_value == syndrome:
                error_position = col
                corrected_codeword[col] ^= 1
                break

        if error_position is None:
            # Syndrome doesn't match any column - shouldn't happen with valid H
            error_type = "unknown"
            corrected = False

    elif syndrome != 0 and overall == 0:
        # Double bit error detected (cannot correct)
        error_type = "double_detected"

    else:
        # Should not reach here
        error_type = "unknown"

    # Extract data bits from corrected codeword (positions r through r+k-1)
    corrected_data_bits = [corrected_codeword[r + i] for i in range(k)]
    corrected_data = _bits_to_int(corrected_data_bits)

    return SECDEDResult(
        corrected_data=corrected_data,
        syndrome=syndrome,
        overall_parity=overall,
        error_type=error_type,
        error_position=error_position,
        corrected=corrected
    )


def inject_error(codeword: List[int], positions: List[int]) -> List[int]:
    """Inject bit errors at specified positions for testing.

    Args:
        codeword: Original codeword as list of bits
        positions: List of bit positions to flip (0-indexed)

    Returns:
        New codeword with bits flipped at specified positions
    """
    corrupted = codeword.copy()
    for pos in positions:
        if 0 <= pos < len(corrupted):
            corrupted[pos] ^= 1
    return corrupted
